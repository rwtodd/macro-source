#!/usr/bin/env lua

--[[ #######################################################################
Assume prefix @.  First line of the file can change it, for example:
  PREFIX: ??

Verbatim chunk definition:
??/name goes here/
verbatim text
??

Lua subroutine chunk definition:
??/name goes here/l
table.insert(result, 'hi there!')
??

Raw lua code to run during file parse:
??/()/l
counter = 1 -- anything goes!
??

Now, inside the code, you can call on chunks like:
void do_it(int a) {
  ??(name goes here)
  ??(this one has args(2, 3))
}
###################################################################### ]]
-- result is global, so it can be altered by user functions
local prefix, def_start, def_templ, def_code, def_end, def_use, def_call
local line_stack     = { first = 1, last = 0 }
local code_fragments = { }
local eval_env       = { 
	result = {};    string=string; 
	table=table;    math=math 
}

-- The prefix is provided by the user, and becomes part of a pattern.  So, we
-- need to escape any pattern-special chars in it.
local escape_lua_pattern
do
	local matches = {
		["^"] = "%^"; ["$"] = "%$"; ["("] = "%("; [")"] = "%)";
		["%"] = "%%"; ["."] = "%."; ["["] = "%["; ["]"] = "%]";
		["*"] = "%*"; ["+"] = "%+"; ["-"] = "%-"; ["?"] = "%?";
		["\0"] = "%z";
	}
	escape_lua_pattern = function(s) return (s:gsub(".", matches)) end
end

-- The two states parsing can be in are: "parse_line_state" and "search_state".
-- These are both functions that parse lines and return which state should be next.
function search_state(l)  
	return l:match('^%s*$') and search_state or parse_line_state(l)
end

function parse_line_state(l)
	local _, pfx_loc = l:find(def_start)
	if pfx_loc then
		@.(attempt to parse a template)
	end
	line_stack.last             = line_stack.last + 1
	line_stack[line_stack.last] = l
	return parse_line_state
end

@./attempt to parse a template/
local name, args, opts 
name = l:match(def_templ, pfx_loc + 1)
if not name then
	name, args, opts = l:match(def_code, pfx_loc + 1)
end
if name then
	@.(read a fragment)
	@.(evaluate the fragment)
	@.(append the fragment to code_fragments)
	return search_state
end
@.

@./read a fragment/
local frag, cur = {}, assert(io.read('l'),name)
while not cur:match(def_end) do
	frag[#frag + 1], cur = cur, assert(io.read('l'),name)
end
@.

@./evaluate the fragment/
-- depending on the selected option, we will evaluate the fragment
-- So, no option generates a table-moving function, 
-- l is lua code, and it's executed immediately if the name is blank
-- t is a template where {{args}} are replaced with given arguments
if opts == nil then
	local f = frag  -- capture frag as-is...
	frag = function() table.move(f, 1, #f, #eval_env.result+1, eval_env.result) end
elseif opts == 'l' and name == '' then
	local func = assert(load(table.concat(frag,'\n'), '', 't', eval_env))
	func()
elseif opts == 'l' then
    local code, func
	code = string.format('return function%s\n%s\nend',args or '()',table.concat(frag, '\n'))
	func = assert(load(code, '', 't', eval_env))
	frag = func()
elseif opts == 't' then
	@.(make sure no args are given)
	local f = frag  -- capture frag as-is...
	frag = function (opts)
		for _,str in ipairs(f) do 
			eval_env.result[#eval_env.result+1] = str:gsub('{{(%w+)}}',opts)
		end
	end
else
	assert(nil,'fragment option: ' .. opts)
end
@.

@./make sure no args are given/
if args ~= '()' then
	assert(nil, 'Args must be () for template fragments: ' .. name)
end
@.

@./append the fragment to code_fragments/
-- we need to account for the case where the name is not yet
-- in the code_fragments list yet, and also just skip everything
-- if the name is '' or the frag is nil
if name ~= '' and frag then
	local flist = code_fragments[name]
	if flist then table.insert(flist,frag)
	         else code_fragments[name] = {frag}
	end
end
@.

-- input phase
do
	@.(set the prefix based on the first line)
	@.(read the remaining input)
end

@./set the prefix based on the first line/
local line = io.read('l')
if line then
	prefix = line:match('^%s*PREFIX:%s*(.-)%s*$')
	if prefix then line = ''
	          else prefix = '@.'
	end
end
prefix = escape_lua_pattern(prefix)

def_start = '^%s*' .. prefix .. '%s*/'
def_templ = '^%s*(.-)%s*/%s*$'
def_code  = '^%s*(.-)%s*(%b())%s*/(%w)%s*$'
def_end   = '^%s*' .. prefix .. '%s*$'
def_use   = prefix .. '%s*%(%s*([^(]-)%s*%)'
def_call  = prefix .. '%s*%(%s*(.-)%s*(%b())%s*%)'
@.

@./read the remaining input/
local st = search_state(line)
while true do
	line = io.read('l')
	if line == nil then break end
	st = st(line)
end
@.

-- output phase
while line_stack.first <= line_stack.last do
	local l = line_stack[line_stack.first]
	line_stack.first = line_stack.first + 1
	local pre, post, name, args
	pre, post, name = l:find(def_use)
	if not pre then pre, post, name, args = l:find(def_call) end
	if name then
		@.(format a used fragment into the line_stack)
	else
		print(l)
	end
end

@./ format a used fragment into the line_stack /
eval_env.result = {}
for _, frag in ipairs(assert(code_fragments[name], name)) do
	@.(expand the fragment into the result table)
end
local result, rlen = eval_env.result, #eval_env.result
@.(indent the result)
line_stack.first = line_stack.first - rlen
table.move(result, 1, rlen, line_stack.first, line_stack)
@.

@./expand the fragment into the result table/
if type(frag) == 'table' then
	table.move(frag, 1, #frag, #eval_env.result+1, eval_env.result)
else
	local fcall = string.format("frag%s", args or '()')
	eval_env.frag = frag
	local chunk = assert(load(fcall, '', 't', eval_env), fcall)
	chunk()	
end
@.

@./ indent the result /
if rlen > 0 then
	local whitespace = l:sub(1,pre-1):gsub('%S',' ')
	result[1]    = l:sub(1,pre-1) .. result[1]
	for idx=2,rlen do
		result[idx] = whitespace .. result[idx]
	end
	result[rlen] = result[rlen] .. l:sub(post+1)
else
	-- there are no results... put in the pre+post string
	result[1] = l:sub(1,pre-1) .. l:sub(post+1)
	if result[1]:find("%S") then
		rlen = 1
	end
end
@.
-- vim: filetype=lua:tabstop=4:tw=0:noet:
