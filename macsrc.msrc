#!/usr/bin/env perl

use v5.30;
use feature qw/signatures refaliasing/;
no warnings qw/experimental::signatures experimental::refaliasing/;

my $prefix = '@.';     # user sets this on first line of file
my $def_start = undef; # regex for definition start
my $def_end = undef;   # regex for definition end
my $def_use = undef;   # regex for fragment use

my %code_fragments;    # the collected code fragments
my $cur_frag_name;     # the fragment we are collecting
my @line_stack;        # the non-code lines to process

my %globals;           # a place where code_fragments can store values
my @result;            # the array into which code_fragments push results

# ######################################################################
# Assume prefix @.  First line of the file can set PREFIX: ??
#
# Verbatim chunk definition:
# @./name goes here/
# verbatim text
# @.
#
# Perl subroutine chunk definition:
# @./name goes here/p
# push @result, 'hi there!';
# @.
#
# Raw perl code to run during file parse:
# @.//p
# my $counter = 1;  # anything goes!
# @.
#
# Now, inside the code, you can call on chunks like:
# void do_it(int a) {
#   @.(name goes here)
#   @.(this one has args(2, 3))
# }
# ######################################################################

sub search_state; #fwd reference

# define the parsing states we can be in
sub parse_line_state($l) {
	if($l =~ $def_start) {
		@.(parse a fragment definition)
		\&search_state;
	} else {
		push @line_stack, $l;
		\&parse_line_state;
	}
}

@./parse a fragment definition/
my ($name, $vars, $opt) = ($1, $2, $3);
die "empty fragment name!" if(not ($name || $opt));
@.(read until end of fragment into @body)
if(not $opt) {
	push $code_fragments{$name}->@*, \@body;
} else {
	if($name) {
		my $compiled = eval ("sub$vars { " . (join "\n", @body) . ' }');
		push $code_fragments{$name}->@*, $compiled; 
	} else {
		# it's an anonymous code block to execute now!
		eval (join "\n", @body);
	}
}
@.

@./read until end of fragment into @body/
my @body = ();
while(<>) {
	chomp;
	last if(/$def_end/);
	push @body, $_;
}
@.

sub search_state($l) {
	if($l =~ m/^\s*$/) {
		\&search_state; 
	} else {
		parse_line_state($l);
	}
}

# step one... read the entire input
#
# the first line might be a prefix...
chomp(my $line = <>);
if($line =~ /^ \s* PREFIX: \s* (.*?) \s* $/x) {
	$prefix = $1;
	$line = '';
}
$def_start = qr{^ 
	\s* \Q$prefix\E / \s* (.*?) \s* 
	( \( (*PRUNE) (?: (?> [^()]+ ) | (?2) )*\) )?  # fragment arguments
	/ (p?) \s* $}x;
$def_end   = qr{^ \s* \Q$prefix\E \s* $}x;
$def_use   = qr{
	\Q$prefix\E \(                                     # opening paren
		\s* (.*?) \s*                                  # fragment name
		( \( (*PRUNE) (?: (?> [^()]+ ) | (?2) )*\) )?  # fragment arguments
	\s* \)                                             # closing paren
}x;

# run a state machine where $st holds the next state function to run
# and each state function returns a ref to the next state
my $st = search_state($line);
while(<>) {
	chomp;
	$st = &$st($_);
}

# step two... run through the line stack, making replacements.

while(scalar @line_stack) {
	my $cur_line = shift @line_stack;
	if ($cur_line =~ /$def_use/) {
		@.(expand a used fragment)
	} else {
		# if there's no replacement to be made, output it
		say $cur_line;
	}
}

@./expand a used fragment/
@result = ();
\my @frags = $code_fragments{$1} // die "Fragment <$1> not found!";
foreach my $frag (@frags) {
	if(ref($frag) eq 'CODE') {
		eval "&\$frag$2";
	} else {
		push @result, $frag->@*;
	}
}
@.(indent the result)
unshift @line_stack, @result;	
@.

@./indent the result/
if(@result) {
	# we have result lines, so put whatever came before the match on
	# the first line, and whatever came after the match on the last
	# line, then add whitespace to indent the lines.
	$result[0] = $` . $result[0];
	$result[$#result] .= $';
	my $indentation = $` =~ s/\S/ /gr; # pre-match converted to whitespace
	for my $i (1..$#result) {
		$result[$i] = $indentation . $result[$i];
	} 
} else {
	# result was empty, but we might have a prefix/postfix we need to
	# insert anyway... if it was all whitespace then remove the line.
	my $prepost = "$`$'";
	push @result, $prepost if($prepost =~ m/\S/);
}
@.
# vim:ft=perl:
