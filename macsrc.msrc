#!/usr/bin/env lua

--[[ #######################################################################
Assume prefix @.  First line of the file can change it, for example:
  PREFIX: ??

Verbatim chunk definition:
??/name goes here/
verbatim text
??

Lua subroutine chunk definition:
??/name goes here/l
table.insert(result, 'hi there!')
??

Raw lua code to run during file parse:
??/()/l
counter = 1 -- anything goes!
??

Now, inside the code, you can call on chunks like:
void do_it(int a) {
  ??(name goes here)
  ??(this one has args(2, 3))
}
###################################################################### ]]
-- result is global, so it can be altered by user functions
result = { }
local prefix, def_start, def_templ, def_code, def_end, def_use, def_call
local line_stack     = { first = 1, last = 0 }
local code_fragments = { }
local eval_env       = setmetatable({}, { __index = _G })

-- The two states parsing can be in are: "parse_line_state" and "search_state".
-- These are both functions that parse lines and return which state should be next.
function search_state(l)  
	return l:match('^%s*$') and search_state or parse_line_state(l)
end

function parse_line_state(l)
	local _, pfx_loc = l:find(def_start)
	if pfx_loc then
		@.(attempt to parse a template)
	end
	line_stack.last             = line_stack.last + 1
	line_stack[line_stack.last] = l
	return parse_line_state
end

@./attempt to parse a template/
local name, args, opts 
name = l:match(def_templ, pfx_loc + 1)
if not name then
	name, args, opts = l:match(def_code, pfx_loc + 1)
end
if name then
	@.(read a fragment)
	@.(evaluate the fragment)
	@.(append the fragment to code_fragments)
	return search_state
end
@.

@./read a fragment/
local frag, cur = {}, assert(io.read('l'),name)
while not cur:match(def_end) do
	frag[#frag + 1], cur = cur, assert(io.read('l'),name)
end
@.

@./evaluate the fragment/
if opts == nil then
	local f = frag  -- capture frag as-is...
	frag = function() table.move(f, 1, #f, #result+1, result) end
elseif opts == 'l' and name == '' then
	local func = assert(load(table.concat(frag,'\n'), '', 't', eval_env))
	func()
elseif opts == 'l' then
    local code, func
	code = string.format('return function%s\n%s\nend',args or '()',table.concat(frag, '\n'))
	func = assert(load(code, '', 't', eval_env))
	frag = func()
elseif opts == 't' then
	-- to do
else
	assert(nil,'fragment option: ' .. opts)
end
@.

@./append the fragment to code_fragments/
-- we need to account for the case where the name is not yet
-- in the code_fragments list yet, and also just skip everything
-- if the name is '' or the frag is nil
if name ~= '' and frag then
	local flist = code_fragments[name]
	if flist then table.insert(flist,frag)
	         else code_fragments[name] = {frag}
	end
end
@.

-- input phase
do
	@.(set the prefix based on the first line)
	@.(read the remaining input)
end

@./set the prefix based on the first line/
local line = io.read('l')
if line then
	prefix = line:match('^%s*PREFIX:%s*(.-)%s*$')
	if prefix then line = ''
	          else prefix = '@.'
	end
end
def_start = '^%s*' .. prefix .. '%s*/'
def_templ = '^%s*(.-)%s*/%s*$'
def_code  = '^%s*(.-)%s*(%b())%s*/(%w)%s*$'
def_end   = '^%s*' .. prefix .. '%s*$'
def_use   = prefix .. '%s*%(%s*([^(]-)%s*%)'
def_call  = prefix .. '%s*%(%s*(.-)%s*(%b())%s*%)'
@.

@./read the remaining input/
local st = search_state(line)
while true do
	line = io.read('l')
	if line == nil then break end
	st = st(line)
end
@.

-- output phase
while line_stack.first <= line_stack.last do
	local l = line_stack[line_stack.first]
	line_stack.first = line_stack.first + 1
	local pre, post, name, args
	pre, post, name = l:find(def_use)
	if not pre then pre, post, name, args = l:find(def_call) end
	if name then
		@.(format a used fragment into the line_stack)
	else
		print(l)
	end
end

@./ format a used fragment into the line_stack /
result = {}
local fcall = string.format("frag%s", args or '()')
for _, frag in ipairs(assert(code_fragments[name], name)) do
	eval_env.frag = frag
	local chunk = assert(load(fcall, '', 't', eval_env), fcall)
	chunk()	
end
local rlen = #result
@.(indent the result)
line_stack.first = line_stack.first - rlen
table.move(result, 1, rlen, line_stack.first, line_stack)
@.

@./ indent the result /
if rlen > 0 then
	local whitespace = l:sub(1,pre-1):gsub('%S',' ')
	result[1]    = l:sub(1,pre-1) .. result[1]
	for idx=2,rlen do
		result[idx] = whitespace .. result[idx]
	end
	result[rlen] = result[rlen] .. l:sub(post+1)
else
	-- there are no results... put in the pre+post string
	result[1] = l:sub(1,pre-1) .. l:sub(post+1)
	if result[1]:find("%S") then
		rlen = 1
	end
end
@.
-- vim: filetype=lua:tabstop=4:tw=0:noet:
