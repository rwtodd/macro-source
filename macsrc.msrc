#!/usr/bin/env lua

--[[ #######################################################################
Assume prefix @.  First line of the file can change it, for example:
  PREFIX: ??

Verbatim chunk definition:
??/name goes here, no parens allowed/
verbatim text
??

Lua subroutine chunk definition:
??/name goes here()/
table.insert(result, 'hi there!')
??

Raw lua code to run during file parse:
??/()/
counter = 1 -- anything goes!
??

Template chunk:
??/name here/t
??

Now, inside the code, you can call on chunks like:
void do_it(int a) {
  ??(name goes here)
  ??(this one has args(2, 3))
}
###################################################################### ]]
-- result is global, so it can be altered by user functions
local prefix
local def_start, def_frag, def_code, def_templ, def_end, def_use, def_call
local line_stack     = { first = 1, last = 0 }
local code_fragments = { }
local eval_env       = { 
	result = {};    string=string; 
	table=table;    math=math 
}

-- The prefix is provided by the user, and becomes part of a pattern.  So, we
-- need to escape any pattern-special chars in it.
local escape_lua_pattern
do
	local matches = {
		["^"] = "%^"; ["$"] = "%$"; ["("] = "%("; [")"] = "%)";
		["%"] = "%%"; ["."] = "%."; ["["] = "%["; ["]"] = "%]";
		["*"] = "%*"; ["+"] = "%+"; ["-"] = "%-"; ["?"] = "%?";
		["\0"] = "%z";
	}
	escape_lua_pattern = function(s) return (s:gsub(".", matches)) end
end

-- The two states parsing can be in are: "parse_line_state" and "search_state".
-- These are both functions that parse lines and return which state should be next.
function search_state(l)  
	return l:match('^%s*$') and search_state or parse_line_state(l)
end

function parse_line_state(l)
	local _, pfx_loc = l:find(def_start)
	if pfx_loc then
		@.(attempt to parse a definition)
	end
	line_stack.last             = line_stack.last + 1
	line_stack[line_stack.last] = l
	return parse_line_state
end

@./attempt to parse a definition/
local name, args, opts 
name, opts = l:match(def_frag, pfx_loc + 1)
if not name then 
	name, args = l:match(def_code, pfx_loc + 1)
end
if name then
	@.(read a fragment)
	@.(evaluate the fragment)
	@.(append the fragment to code_fragments)
	return search_state
end
@.

@./read a fragment/
local frag, cur = {}, assert(io.read('l'),name)
while not cur:match(def_end) do
	frag[#frag + 1], cur = cur, assert(io.read('l'),name)
end
@.

@./evaluate the fragment/
-- depending on how the l:match'es went, we will be in one of these
-- states:
--   1) name set, args nil, opts = ''     TEXT FRAGMENT
--   2) name set, args nil, opts = 't'    TEMPLATE
--   3) name set, args set, opts nil      CODE FRAGMENT
--   4) name '',  args set, opts nil      IMMEDIATE CODE
if not args then
	local f = frag  -- capture frag as-is...
	if opts==''
	then   -- TEXT FRAGMENT
		frag = function()
			table.move(f, 1, #f, #eval_env.result+1, eval_env.result)
		end
	else   -- TEMPLATE
		frag = function (opts)
			for _,str in ipairs(f) do 
				eval_env.result[#eval_env.result+1] = str:gsub('{{(%w+)}}',opts)
			end
		end
	end
else
	if name == '' then  -- IMMEDIATE CODE
		local func = assert(load(table.concat(frag,'\n'), '', 't', eval_env))
		func()
	else   -- CODE FRAGMENT
    	local code, func
		code = string.format('return function%s\n%s\nend',args,table.concat(frag, '\n'))
		func = assert(load(code, '', 't', eval_env))
		frag = func()
	end
end
@.

@./append the fragment to code_fragments/
-- we need to account for the case where the name is not yet
-- in the code_fragments list yet, and also just skip everything
-- if the name is '' or the frag is nil
if name ~= '' then
	local flist = code_fragments[name]
	if flist then table.insert(flist,frag)
	         else code_fragments[name] = {frag}
	end
end
@.

-- input phase
do
	@.(set the prefix based on the first line)
	@.(read the remaining input)
end

@./set the prefix based on the first line/
local line = io.read('l')
if line then
	prefix = line:match('^%s*PREFIX:%s*(.-)%s*$')
	if prefix then line = ''
	          else prefix = '@.'
	end
end
prefix = escape_lua_pattern(prefix)

def_start = '^%s*' .. prefix .. '%s*/'
def_frag  = '^%s*([^(]-)%s*/(t?)%s*$'
def_code  = '^%s*(.-)%s*(%b())%s*/%s*$'
def_end   = '^%s*' .. prefix .. '%s*$'

def_use_start = prefix .. '%s*%(%s*([^({})]-)%s*[(){]'
def_call      = '(%b())%s*%)'
def_tbl_call  = '(%b{})%s*%)'
@.

@./read the remaining input/
local st = search_state(line)
while true do
	line = io.read('l')
	if line == nil then break end
	st = st(line)
end
@.

-- output phase
while line_stack.first <= line_stack.last do
	local l = line_stack[line_stack.first]
	line_stack.first = line_stack.first + 1
	local pre, post, name, char, args
	pre, post, name = l:find(def_use_start)
	if pre then
		@.(determine the call format)
	end
	if args then
		@.(format a used fragment into the line_stack)
	else
		print(l)
	end
end

@./ determine the call format/
-- if it just ends with a ')' then it's a plain fragment call
-- otherwise, try to match arguments types as list or table
-- In any case, leave 'args' set if we matched, and post is the
-- end of the total match
if l:sub(post,post) == ')' then
	args = '()'
else
	local post2
	_, post2, args = l:find(def_call,post)
	if not args then
		_, post2, args = l:find(def_tbl_call,post)
	end
	post = post2
end
@.

@./ format a used fragment into the line_stack /
eval_env.result = {}
for _, frag in ipairs(assert(code_fragments[name], name)) do
	@.(expand the fragment into the result table)
end
local result, rlen = eval_env.result, #eval_env.result
@.(indent the result)
line_stack.first = line_stack.first - rlen
table.move(result, 1, rlen, line_stack.first, line_stack)
@.

@./expand the fragment into the result table/
if type(frag) == 'table' then
	table.move(frag, 1, #frag, #eval_env.result+1, eval_env.result)
else
	local fcall = string.format("frag%s", args)
	eval_env.frag = frag
	local chunk = assert(load(fcall, '', 't', eval_env), fcall)
	chunk()	
end
@.

@./ indent the result /
if rlen > 0 then
	local whitespace = l:sub(1,pre-1):gsub('%S',' ')
	result[1] = l:sub(1,pre-1) .. result[1]
	for idx=2,rlen do
		result[idx] = whitespace .. result[idx]
	end
	result[rlen] = result[rlen] .. l:sub(post+1)
else
	-- there are no results... put in the pre+post string
	result[1] = l:sub(1,pre-1) .. l:sub(post+1)
	if result[1]:find("%S") then
		rlen = 1
	end
end
@.
-- vim: filetype=lua:tabstop=4:tw=0:noet:
