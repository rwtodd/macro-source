#!/usr/bin/env perl

use v5.30;
use feature qw/signatures refaliasing/;
no warnings qw/experimental::signatures experimental::refaliasing/;

# ######################################################################
# MSRC-PRIME -- just enough of an implementation to run against 
# macsrc.msrc and bootstrap.  The full macsrc is written such that it
# only uses facilities provided by msrc-prime.
#
# LIMITATIONS of msrc-prime:
# - Only one fragment call per line.
# - No code fragments, only replacement texts
# - No error checking
# - No way to change the PREFIX
# - No checks for recursion going out of control
# - No indentention information available
# - No global varaible hash for code to share data.
# - No arguments passed to fragments 
# - Can't add to an existing fragment definition
# ... these will all be address in the full macsrc
#
# ######################################################################

my $prefix = '@.';     # user sets this on first line of file
my $def_start = qr{ ^ \s* $prefix \s* / \s* (.*?) \s* / \s* $}x;
my $def_end   = qr{^ \s* $prefix \s* $}x;
my $def_use   = qr{^ \s* $prefix \( \s* (.*?) \s* \) \s* $}x;

my %code_fragments;    # the collected code fragments
my $cur_frag_name;     # the fragment we are collecting
my @line_stack;        # the non-code lines to process

my @result;      # the array into which code_fragments push results

sub read_until($rx) {
	my @lines = ();
	while(<>) {
		chomp;
		last if(/$rx/);
		push @lines, $_;
	}
	\@lines
}

# The two states parsing can be in are: "parse_line_state" and "search_state".
# These are both subs that parse lines and return which state should be next.

sub search_state; #fwd reference
sub parse_line_state($l) {
	if($l =~ $def_start) {
		my $name = $1;
		die "empty fragment name!" if(not $name);
		$code_fragments{$name} = read_until($def_end);
		\&search_state;
	} else {
		push @line_stack, $l;
		\&parse_line_state;
	}
}

sub search_state($l) {
	if($l =~ m/^\s*$/) {
		\&search_state; 
	} else {
		parse_line_state($l);
	}
}

# step one... read the entire input via the state machine defined above.
my $st = \&search_state;
while(<>) {
	chomp;
	$st = &$st($_);
}

# step two... run through the line stack, making replacements.
while(scalar @line_stack) {
	my $cur_line = shift @line_stack;
	if ($cur_line =~ /$def_use/) {
		unshift @line_stack, $code_fragments{$1}->@*;
	} else {
		say $cur_line;
	}
}

# vim:ft=perl:
