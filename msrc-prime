#!/usr/bin/perl

use v5.030;
use feature 'signatures';
no warnings 'experimental::signatures';
use feature 'refaliasing';
no warnings 'experimental::refaliasing';

# ######################################################################
# MSRC-PRIME -- just enough of an implementation to run against 
# macsrc.msrc and bootstrap.  The full macsrc is written such that it
# only uses facilities provided by msrc-prime.
#
# LIMITATIONS of msrc-prime:
# - Only one fragment call per line.
# - No code fragments, only replacement texts
# - No error checking
# - No way to change the PREFIX
# - No checks for recursion going out of control
# - No indentention information available
# - No global varaible hash for code to share data.
# - No arguments passed to fragments 
# - Can't add to an existing fragment definition
# ... these will all be address in the full macsrc
#
# ######################################################################
# Assume prefix @.  First line of the file can set PREFIX: ??
#
# Verbatim chunk definition:
# @./name goes here/
# verbatim text
# @.
#
# Perl subroutine chunk definition:
# @./name goes here/p
# push @result, 'hi there!';
# @.
#
# Raw perl code:
# @.//p
# my $counter = 1;  # anything goes!
# @.
#
# Now, inside the code, you can call on chunks like:
# void do_it(int a) {
#   @.(name goes here)
#   @.(this one has args(2, 3))
# }
# ######################################################################

my $prefix = '@.';     # user sets this on first line of file
my $def_start = qr{ ^ \s* $prefix \s* / \s* (.*?) \s* / \s* $}x;
my $def_end   = qr{^ \s* $prefix \s* $}x;
my $def_use   = qr{^ \s* $prefix \( \s* (.*?) \s* \) \s* $}x;

my %code_fragments;    # the collected code fragments
my $cur_frag_name;     # the fragment we are collecting
my @line_stack;        # the non-code lines to process

my @result;      # the array into which code_fragments push results

sub read_until($rx) {
	my @lines = ();
	while(<>) {
		chomp;
		last if(/$rx/);
		push @lines, $_;
	}
	\@lines
}

sub search_state; #fwd reference

# define the parsing states we can be in
sub parse_line_state($l) {
	if($l =~ $def_start) {
		my $name = $1;
		die "empty fragment name!" if(not $name);
		$code_fragments{$name} = read_until($def_end);
		\&search_state;
	} else {
		push @line_stack, $l;
		\&parse_line_state;
	}
}

sub search_state($l) {
	if($l =~ m/^\s*$/) {
		\&search_state; 
	} else {
		parse_line_state($l);
	}
}

# step one... read the entire input
#
my $st = \&search_state;
while(<>) {
	chomp;
	$st = &$st($_);
}

# step two... run through the line stack, making replacements.
while(scalar @line_stack) {
	my $cur_line = shift @line_stack;
	if ($cur_line =~ /$def_use/) {
		unshift @line_stack, $code_fragments{$1}->@*;
	} else {
		# if there's no replacement to be made, output it
		say $cur_line;
	}
}

# vim:ft=perl:
